<p><strong>How/where to use the logical and bit-wise operators?</strong></p><p>(thanks to Jaya)</p><p><br></p><p><em>'NOT' can take just one input, and has a single output. Suppose I have a vector. How will NOT work on it?<br>Also, it has been mentioned that it is better to use logical operators inside if(), while(), etc and not in procedures.<br></em></p><pre class="prettyprint linenums">reg [7:0] a= 8'b 1111_0000;
reg [7:0] b= 8'b 1010_0100;
reg [7:0] c;
c = a &amp;&amp; b; // c gets 1 bit value</pre><p><em>Can you please tell me how c can get only one bit value if it is defined as an 8 bit register?<br>Also, if it does get just one bit value, what is it? Which bit of a and b does it consider for calculating its value?</em></p><p><br></p><p>Here are my answers to this question:</p><p><br></p><p>1. Bit-wise 'NOT' (~) can take just one input, and has a single output. "Suppose I have a vector. How will NOT work on it?"</p><pre class="prettyprint linenums">reg [7:0] a; reg [7:0]b;
a[0] =~ b[0]; // creates a NOT gate that has b[0] as input and a[0] as output
a[7:1] = ~b[7:1] // creates an array of NOT gates (7 at number) that have b[i] as inputs and a[i] as outputs</pre><p>As you correctly said it works on vectors but the hardware circuit will be an array of individual NOT gates with 1 input and 1 output. I said 1 input and 1 output from the logic gates perspective, since an AND gate has at least 2 inputs and 1 output.</p><p><br></p><p>2. "Also, it has been mentioned that it is better to use logical operators inside if(), while(), etc and not in procedures."</p><p><strong>Best practice rule:</strong></p><p><br></p><pre class="prettyprint linenums">if (!a) begin // logical conditions if, while use logical operators
your code
end</pre><p><br></p><pre class="prettyprint linenums">always @(*) begin
a[7:0] =~b[7:0]; // bit-wise operations use bit-wise operators
if(!e) begin // if e==0 perform the following AND -&gt; uses logical operator because if is a logic operation
c[7:0] = a[7:0] &amp; d[7:0]
end
end</pre><p><br></p><p>In Verilog when you use always@ procedures for synthesizable code so you need bit-wise operators that translate to logic gates that perform operations between the involved vectors/bits. if/while use only logical operations between their brackets. Also synthesis tools give the best results when you use the above rule.</p><p><br></p><p>3.</p><pre class="prettyprint linenums">reg [7:0] a= 8'b 1111_0000;
reg [7:0] b= 8'b 1010_0100;
reg [7:0] c;
c = a &amp;&amp; b; // c gets 1 bit value</pre><p>Can you please tell me how c can get only one bit value if it is defined as an 8 bit register?<br>Also, if it does get just one bit value, what is it? Which bit of a and b does it consider for calculating its value?</p><p><br></p><p><strong>c = a &amp;&amp; b; </strong>means check if a and b are both non-zero. Since they are vectors a single bit of 1, whatever the position (in a and also in b ) would return a logic 1 (one bit). c[7:0] = 8'b0000_00001 (it is placed in the least significant bit to readapt to the destination size).</p><p>The only moment when c = 8'b0000_0000 is only when a = 8'b0000_0000 or b = 8'b0000_0000 (or both are 0).</p><p><strong>c = a &amp; b;</strong> means to perform bit-wise AND between a[i] and b[i] and put the result in c[i]. if we take the above values it means that c = 8'b1010_0000 = 8'd160. Also if a = 8'h55 and b= 8'hAA then c = a &amp;b = 8'b0000_0000.</p><p>I hope this example makes clear the difference between the &amp;&amp; and &amp; operators.</p>